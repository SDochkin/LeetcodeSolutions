# 70. Climbing Stairs

Классическая задача на динамическое программирование. Идея в том, что зная предыдущий результат, можно вычислить следующий, не прогоняя все вычисления заново.

Мы знаем, что для того, чтобы подняться на первую ступеньку, у нас есть только один способ. Мы можем посчитать, что подняться на 2 ступеньки можно двумя способами. Теперь у нас есть некоторый базис, с которого мы начнём. На 3 ступеньки можно подняться столькими способами, сколькими можно подняться на 2 предыдущие ступеньки вместе и так далее. Теперь у нас есть зависимость, которую мы можем использовать.

Первый способ - рекурсивные вызовы. Мы можем либо вернуть результат, если число меньше или равно 2, потому что мы его посчитали заранее, либо вернуть сумму от результата вычислений для предыдущей ступеньки (текущая - 1) и ступеньки перед ней (текущая - 2). Алгоритм не оптимальный, съедает очень много памяти, поэтому можем реализовать мемоизацию, записывая результаты предыдущих вычислений в массив и возвращая их, если они есть, а если нет, тогда запускать вычисления.

Второй способ - перебор. Идея похожая, мы кладём в массив базовые случаи и заводим цикл  длиной меньше или равной переданному числу. Стартовать будем с индекса, которого ещё нет в массиве. Далее просто кладём в текущий индекс сумму предыдущего и предпредыдущего индексов массива и возвращаем результат.
