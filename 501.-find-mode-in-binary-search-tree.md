# 501. Find Mode in Binary Search Tree

Важно понимать, что mode (максимальный по количеству набор вершин с одним значением) в дереве один. Дерево у нас BST, это значит, что оно упорядоченное (данные отсортированы по возрастанию).

Решать будем так:  мы можем пойти по дереву рекурсией (например, алгоритм DFS) и перебрать значения узлов, записывая одинаковые в массив. При этом, у нас должен быть некий счётчик текущей длины последовательности и максимальной длины последовательности, которую мы успели посчитать, также нам нужно где-то хранить предыдущую ноду, чтобы сравнивать прошлые и текущие значения.&#x20;

Описываем случай, когда нода пустая, просто делаем return. Далее, запускаем рекурсию, передаём в неё ноду слева от текущей. Пишем условие счётчика (либо прибавляем к текущему единицу, если значения нод равны, либо сбрасываем счётчик до единицы, если новое значение ноды больше предыдущего). Не забываем положить текущую ноду в переменную для предыдущей ноды.&#x20;

Обновление счётчика для текущей итерации закончили, предыдущую ноду заменили, теперь смотрим в счётчики. Если текущий счётчик равен максимуму, значит новая максимально-длинная последовательность у нас не найдена и мы просто добавляем значение узла в массим. Если же счётчик стал больше максимума, значит мы нашли новую последовательность и нам надо очистить массив и установить в максимум текущее значение счётчика.

В конце вызовем дфс для правой половины дерева. Снаружи функции вызовем его в принципе, с первым значением и вернём массив результатов.
