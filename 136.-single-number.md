# 136. Single Number

Я нашёл 2 решения.

Первое: собираем мапу где ключ - число из массива, а значение - количество вхождений. Дальше идём по мапе и ищем у какого ключа значение 1 (подойдёт фор ин). Возвращаем ключ.

Второй: шагаем через 2 элемента циклом по отсортированному массиву. Сравниваем текущий и текущий + 1 элементы. Если не равны - возвращаем текущий.

Можно решить побитовым сравнением. Есть операция ^ (XOR - исключающее или), которая работает так: если биты совпадают, то аккумулятор обнуляется, если нет - перезаписывается. Соответственно, мы заводим аккумулятор, инициализируем нулём. Идём по массиву и дописываем через ^ новое число в аккумулятор. В итоге на выходе у нас останется либо ноль, если все числа парами, либо то число, которое не парное.
